use crate::backends::Backend;
use amaru_doctor::model::button::{ButtonId, ButtonPress, InputEvent};
use embedded_graphics_simulator::sdl2::Keycode;
use embedded_graphics_simulator::{OutputSettings, SimulatorDisplay, SimulatorEvent, Window};
use mousefood::embedded_graphics::geometry::Size;
use mousefood::{EmbeddedBackend, EmbeddedBackendConfig, prelude::Rgb565};
use std::sync::mpsc::{self, Receiver, Sender};
use std::time::{Duration, Instant};

const DOUBLE_PRESS_TIMEOUT: Duration = Duration::from_millis(200);
type PendingPress = Option<(ButtonId, Instant)>;

/// Creates the simulator backend and returns it along with a channel receiver
/// for input events generated by the simulator window.
pub fn setup_simulator_and_input() -> (Backend<SimulatorDisplay<Rgb565>>, Receiver<InputEvent>) {
    println!("Setting up simulator hardware and input");
    let mut simulator_window = Window::new(
        "Simulator",
        &OutputSettings {
            scale: 2,
            ..Default::default()
        },
    );
    let display = SimulatorDisplay::<Rgb565>::new(Size::new(320, 240));
    let (tx, rx) = mpsc::channel();
    let mut pending_press: PendingPress = None;

    let backend_config: EmbeddedBackendConfig<SimulatorDisplay<Rgb565>, _> =
        EmbeddedBackendConfig {
            flush_callback: Box::new(move |display| {
                simulator_window.update(display);

                handle_pending_press_timeout(&mut pending_press, &tx);
                process_simulator_events(&mut simulator_window, &mut pending_press, &tx);
            }),
            ..Default::default()
        };

    let backend = EmbeddedBackend::new(Box::leak(Box::new(display)), backend_config);
    (backend, rx)
}

/// Checks if a pending press has timed out and sends a `Short` press event if it has.
fn handle_pending_press_timeout(pending_press: &mut PendingPress, tx: &Sender<InputEvent>) {
    let Some((id, instant)) = pending_press else {
        // No pending press
        return;
    };

    if instant.elapsed() <= DOUBLE_PRESS_TIMEOUT {
        // Still within the pending press timeout
        return;
    }

    // The pending press timeout has passed, send the short press and reset pending
    tx.send(InputEvent {
        id: *id,
        press_type: ButtonPress::Short,
    })
    .ok();
    *pending_press = None;
}

/// Iterates through all available simulator events and dispatches them.
fn process_simulator_events(
    window: &mut Window,
    pending_press: &mut PendingPress,
    tx: &Sender<InputEvent>,
) {
    for event in window.events() {
        match event {
            SimulatorEvent::KeyDown {
                keycode,
                repeat: false,
                ..
            } => {
                handle_keydown_event(keycode, pending_press, tx);
            }
            SimulatorEvent::Quit => {
                panic!("simulator window closed");
            }
            _ => { /* Ignore other events */ }
        }
    }
}

/// Handles the logic for a key press, including double presses.
fn handle_keydown_event(
    keycode: Keycode,
    pending_press: &mut PendingPress,
    tx: &Sender<InputEvent>,
) {
    let button_id = match keycode {
        Keycode::A => Some(ButtonId::A),
        Keycode::B => Some(ButtonId::B),
        Keycode::X => Some(ButtonId::X),
        Keycode::Y => Some(ButtonId::Y),
        _ => None,
    };

    let Some(id) = button_id else {
        // Not a button we recognize
        return;
    };

    let Some((pending_id, _)) = *pending_press else {
        // There's no pending press, this is the first (maybe) press of a double press
        *pending_press = Some((id, Instant::now()));
        return;
    };

    if pending_id == id {
        // This is a double press
        tx.send(InputEvent {
            id,
            press_type: ButtonPress::Double,
        })
        .ok();
        *pending_press = None; // Reset the pending press
    } else {
        // A different button was pressed, the pending was a short press
        tx.send(InputEvent {
            id: pending_id,
            press_type: ButtonPress::Short,
        })
        .ok();
        *pending_press = Some((id, Instant::now())); // New press is now pending
    }
}
